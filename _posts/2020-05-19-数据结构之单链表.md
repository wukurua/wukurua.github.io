---
layout:     post
title:      数据结构之单链表
subtitle:   单链表
date:       2020-05-19
author:     wukurua
header-img: img/DS/post-bg-ds.png
catalog: true
tags:
    - Data Structure
---

# 一、代码

## LinkList.h

```c++

```

## LinkList.cpp

### 头插法

算法简单,但是读入数据的顺序与生成的链表中元素的顺序是相反的.

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520013756.png" style="zoom: 67%;" />

```c++
//时间复杂度O(n)
void listHeadInsert(LinkList &L)
{
	L=(LinkList)malloc(sizeof(LNode));
	L->next=NULL;
	L->data=NULL;
	LNode *s;
	int x;
	scanf("%d",&x);
	while(x!=9999)
	{
		s=(LNode*)malloc(sizeof(LNode));
		s->data=x;
		s->next=L->next;
		L->next=s;
		scanf("%d",&x);
	}
}
```

### 尾插法

读入数据的顺序与生成的链表中元素的顺序一致,但是必须增加一个尾指针r.,使其始终指向当前链表的尾结点.

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520014313.png" style="zoom: 67%;" />

```c++
//时间复杂度O(n)--有尾指针情况下
void listTailInsert(LinkList &L)
{
	L=(LinkList)malloc(sizeof(LNode));
	L->next=NULL;
	L->data=NULL;
	LNode *s,*r=L;
	int x;
	scanf("%d",&x);
	while(x!=9999)
	{
		s=(LNode*)malloc(sizeof(LNode));
		s->data=x;
		r->next=w;
		r=s;
		scanf("%d",&x);
	}
}
```

### 按序号查找&按值查找

```c++
//时间复杂度O(n)
LNode *listGetElm(LinkList &L,int i)
{
	int j=1;
	LNode *p=L->next;
	if(i<0)
		return NULL;
	else if(i==0)
		return L;
	while(p&&j<i)
	{
		p=p->next;	
		j++;
	}
	return p;
}

//时间复杂度O(n)
LNode *listLocateElm(LinkList &L,int e)
{
	LNode *p=L->next;
	while(p&&p->data!=e)
		p=p->next;
	return p;
}
```

### 插入结点

前插法:

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520031119.png" style="zoom: 67%;" />

```c++
//前插法(未知ai结点的位置)--时间复杂度O(n)
void listFrontInsert(LinkList &L,int i)
{
	LNode *p=listGetElm(L,i-1);
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=i;
	s->next=p->next;
	p->next=s;
}

//前插法(已知ai结点的位置)--时间复杂度O(n)
void listFrontInsert(LinkList &L,LNode *ai,int i)
{
	LNode *p=listGetElm(L,i-1);
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=i;
	s->next=ai;
	p->next=s;
}
```

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520024352.png" style="zoom:67%;" />

```c++
//后插法(未知ai结点的位置)--时间复杂度O(n)
void listBackInsert(LinkList &L,int i)
{
	LNode *p=listGetElm(L,i);
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=i;
	s->next=p->next;
	p->next=s;
}

//后插法(已知ai结点的位置)--时间复杂度O(1)
void listBackInsert(LinkList &L,LNode *ai,int i)
{
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=i;
	s->next=ai->next;
	ai->next=s;
}

//前插法转化为后插法实现(已知ai结点的位置)--时间复杂度O(1)
void listBackInsert(LinkList &L,LNode *ai,int i)
{
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=i;
	s->next=ai->next;
	ai->next=s;
	int tmp=ai->data;
	ai->data=s->data;
	s->data=tmp;
}
```

### 删除结点

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520031305.png" style="zoom:67%;" />

```c++
//找前驱节点(未知ai结点的位置)--时间复杂度O(n)
void listDelete(LinkList &L,int i)
{
	LNode *p=listGetElm(L,i-1);
	LNode *q=p->next;
	p->next=q->next;
	free(q);
}
```

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520032241.png" style="zoom:67%;" />

```c++
//删除后继节点(已知ai结点的位置)--时间复杂度O(1)
void listDelete(LinkList &L,LNode *ai)
{
	LNode *q=ai->next;
	ai->data=ai->next->data;
	ai->next=q->next;
	free(q);
}
```



### 遍历结点&求表长

```c++
//时间复杂度O(n)	
void listPrint(LinkList &L)
{
	LNode *p=L;
	while(p->next!=NULL)
	{
		printf("%d ",p->next->data);
		p=p->next;
	}
	printf("\n");
}

//时间复杂度O(n)
int listLength(LinkList &L)
{
	int count=0;
	LNode *p=L;
	while(p->next!=NULL)
	{
		count++;
		p=p->next;
	}
	return count;
}
```



## main.cpp

```c++
#include "LinkList.h"
 
int main()
{
/*
	cout<<"listHeadInsert:"<<endl;
	LinkList H;
	listHeadInsert(H);
	listPrint(H);
*/
	cout<<"listHeadInsert:"<<endl;
	LinkList T;
	listTailInsert(T);
	listPrint(T);

	LNode *s=listGetElm(T,4);
	if(s==NULL)
		cout<<"Error!"<<endl;
	else
		cout<<"4th:"<<s->data<<endl;

	s=listLocateElm(T,4);
	if(s==NULL)
		cout<<"No find!"<<endl;
	else
		cout<<"where is 4:"<<s->data<<endl;

	cout<<"Insert 3:"<<endl;
	listBackInsert(T,3);
	listPrint(T);

	cout<<"length:"<<listLength(T)<<endl;
	
	return 0;
}
```

控制台结果:

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520034451.png)

![image-20200520034530035](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20200520034530035.png)

# 二、概念 问题

## 1.引入头结点的两个优点

- 链表的第一个位置和其他位置的操作统一
- 空表和非空表的操作统一

## 2.顺序表和链表的比较

