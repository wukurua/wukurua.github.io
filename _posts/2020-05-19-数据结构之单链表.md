---
layout:     post
title:      数据结构之单链表
subtitle:   单链表
date:       2020-05-19
author:     wukurua
header-img: img/DS/post-bg-ds.png
catalog: true
tags:
    - Data Structure
---

# 一、代码

## LinkList.h

```c++

```

## LinkList.cpp

### **头插法**:

算法简单,但是读入数据的顺序与生成的链表中元素的顺序是相反的.

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520013756.png" style="zoom: 67%;" />

```c++
//时间复杂度O(n)
void listHeadInsert(LinkList &L)
{
	L=(LinkList)malloc(sizeof(LNode));
	L->next=NULL;
	L->data=NULL;
	LNode *s;
	int x;
	scanf("%d",&x);
	while(x!=9999)
	{
		s=(LNode*)malloc(sizeof(LNode));
		s->data=x;
		s->next=L->next;
		L->next=s;
		scanf("%d",&x);
	}
}
```

**尾插法**:

读入数据的顺序与生成的链表中元素的顺序一致,但是必须增加一个尾指针r.,使其始终指向当前链表的尾结点.

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520014313.png" style="zoom: 67%;" />

```c++
//时间复杂度O(n)--有尾指针情况下
void listTailInsert(LinkList &L)
{
	L=(LinkList)malloc(sizeof(LNode));
	L->next=NULL;
	L->data=NULL;
	LNode *s,*r=L;
	int x;
	scanf("%d",&x);
	while(x!=9999)
	{
		s=(LNode*)malloc(sizeof(LNode));
		s->data=x;
		r->next=w;
		r=s;
		scanf("%d",&x);
	}
}
```

**按序号查找&按值查找**:

```c++
//时间复杂度O(n)
LNode *listGetElm(LinkList &L,int i)
{
	int j=1;
	LNode *p=L->next;
	if(i<0)
		return NULL;
	else if(i==0)
		return L;
	while(p&&j<i)
	{
		p=p->next;	
		j++;
	}
	return p;
}

//时间复杂度O(n)
LNode *listLocateElm(LinkList &L,int e)
{
	LNode *p=L->next;
	while(p&&p->data!=e)
		p=p->next;
	return p;
}
```

**插入结点:**

前插法:

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520021608.png" style="zoom:67%;" />

```c++
//时间复杂度O(n)
void listInsert(LinkList &L,int i)
{
	LNode *p=listGetElm(L,i-1);
	LNode *s=p->next;
	p->next=s;
}
```

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520024352.png" style="zoom:67%;" />

## main.cpp

```c++

```

控制台结果:



# 二、概念 

## 1.引入头结点的两个优点

- 链表的第一个位置和其他位置的操作统一
- 空表和非空表的操作统一

2.

