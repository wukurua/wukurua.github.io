---
layout:     post
title:      手撕数据结构——单链表
subtitle:   单链表
date:       2020-05-19
author:     wukurua
header-img: img/DS/post-bg-ds.png
catalog: true
tags:
    - Data Structure
---

# 一、代码

## LinkList.h

```c++
#ifndef LINKLIST_H
#define LINKLIST_H
#include<iostream>
using namespace std;
const int ENTER=13;

typedef struct LNode
{
	int data;
	struct LNode *next;
}LNode,*LinkList;

/*有头结点*/
//头插法
void listHeadInsert(LinkList &L);
//尾插法
void listTailInsert(LinkList &L);
//按序号查找
LNode *listGetElm(LinkList &L,int i);
//按值查找
int listLocateElm(LinkList &L,int e);
//插入结点--前插法
bool listFrontInsert(LinkList &L,int i,int e);
bool listFrontInsert(LinkList &L,LNode *ai,int e);
//插入结点--后插法
bool listBackInsert(LinkList &L,int i,int e);
bool listBackInsert(LinkList &L,LNode *ai,int e);
bool listFrontToBackInsert(LinkList &L,LNode *ai,int e);
//删除结点
bool listDelete(LinkList &L,int i);
bool listDelete(LinkList &L,LNode *ai);
//遍历结点
void listPrint(LinkList &L);
//求表长
int listLength(LinkList &L);
//是否为空
bool listEmpty(LinkList &L);
//销毁链表
void listDestory(LinkList &L);
//逆置链表
void listReverse1(LinkList &L);
void listReverse2(LinkList &L);
#endif
```

## LinkList.cpp

### 头插法

算法简单,但是读入数据的顺序与生成的链表中元素的顺序是相反的.

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520013756.png" style="zoom: 67%;" />

```c++
//时间复杂度O(n)
void listHeadInsert(LinkList &L)
{
	L=(LinkList)malloc(sizeof(LNode));
	L->next=NULL;
	L->data=NULL;
	LNode *s;
	int x;
	scanf("%d",&x);
	while(x!=9999)
	{
		s=(LNode*)malloc(sizeof(LNode));
		s->data=x;
		s->next=L->next;
		L->next=s;
		scanf("%d",&x);
	}
}
```

### 尾插法

读入数据的顺序与生成的链表中元素的顺序一致,但是必须增加一个尾指针r.,使其始终指向当前链表的尾结点.

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520014313.png" style="zoom: 67%;" />

```c++
//时间复杂度O(n)--有尾指针情况下
void listTailInsert(LinkList &L)
{
	L=(LinkList)malloc(sizeof(LNode));
	L->next=NULL;
	L->data=NULL;
	LNode *s,*r=L;
	int x;
	scanf("%d",&x);
	while(x!=9999)
	{
		s=(LNode*)malloc(sizeof(LNode));
		s->data=x;
		r->next=w;
		r=s;
		scanf("%d",&x);
	}
}
```

### 按序号查找&按值查找

```c++
//时间复杂度O(n)
LNode *listGetElm(LinkList &L,int i)
{
	int j=1;
	LNode *p=L->next;
	if(i<0)
		return NULL;
	else if(i==0)
		return L;
	while(p&&j<i)
	{
		p=p->next;	
		j++;
	}
	return p;
}

//时间复杂度O(n)
int listLocateElm(LinkList &L,int e)
{
	LNode *p=L->next;
	int i=1;
	while(p&&p->data!=e)
	{
		p=p->next;
		i++;
	}
	if(p==NULL)
		return 0;
	else
		return i;
}
```

### 插入结点

前插法:

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520031119.png" style="zoom: 67%;" />

```c++
//前插法(未知ai结点的位置)--时间复杂度O(n)
bool listFrontInsert(LinkList &L,int i,int e)
{
	LNode *p=listGetElm(L,i-1);
	if(p==NULL)
		return false;
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=e;
	s->next=p->next;
	p->next=s;
	return true;
}

//前插法(已知ai结点的位置)--时间复杂度O(n)
bool listFrontInsert(LinkList &L,LNode *ai,int e)
{
	int aie=ai->data;
	int i=listLocateElm(L,aie);
	LNode *p=listGetElm(L,i-1);
	if(p==NULL)
		return false;
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=e;
	s->next=p->next;
	p->next=s;
	return true;
}
```

后插法:

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520024352.png" style="zoom:67%;" />

```c++
//后插法(未知ai结点的位置)--时间复杂度O(n)
bool listBackInsert(LinkList &L,int i,int e)
{
	LNode *p=listGetElm(L,i);
	if(p==NULL)
		return false;
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=e;
	s->next=p->next;
	p->next=s;
	return true;
}

//后插法(已知ai结点的位置)--时间复杂度O(1)
bool listBackInsert(LinkList &L,LNode *ai,int e)
{
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=e;
	s->next=ai->next;
	ai->next=s;
	return true;
}

//前插法转化为后插法实现(已知ai结点的位置)--时间复杂度O(1)
bool listFrontToBackInsert(LinkList &L,LNode *ai,int e)
{
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=e;
	s->next=ai->next;
	ai->next=s;
	int tmp=ai->data;
	ai->data=s->data;
	s->data=tmp;
	return true;
}
```

### 删除结点

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520031305.png" style="zoom:67%;" />

```c++
//找前驱节点(未知ai结点的位置)--时间复杂度O(n)
bool listDelete(LinkList &L,int i)
{
	LNode *p=listGetElm(L,i-1);
	if(p==NULL)
		return false;
	LNode *q=p->next;
	p->next=q->next;
	free(q);
	return true;
}
```

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520032241.png" style="zoom:67%;" />

```c++
//删除后继节点(已知ai结点的位置)--时间复杂度O(1)
bool listDelete(LinkList &L,LNode *ai)
{
	LNode *q=ai->next;
	ai->data=q->data;
	ai->next=q->next;
	free(q);
	return true;
}
```



### 遍历结点&求表长

```c++
//时间复杂度O(n)	
void listPrint(LinkList &L)
{
	LNode *p=L;
	while(p->next!=NULL)
	{
		printf("%d ",p->next->data);
		p=p->next;
	}
	printf("\n");
}

//时间复杂度O(n)
int listLength(LinkList &L)
{
	int count=0;
	LNode *p=L;
	while(p->next!=NULL)
	{
		count++;
		p=p->next;
	}
	return count;
}
```

### 是否为空

```c++
bool listEmpty(DLinkList &L)
{
	if(L->next==NULL)
		return true;
	else
		return false;
}
```

### 销毁链表

```c++
void listDestory(LinkList &L)
{
	LNode *p=L;
	LNode *q=NULL;
	while(p)
	{
		q=p->next;
		free(p);
		p=q;
	}
}
```

### 逆置链表

方法一:将头结点摘下,然后从第一个结点开始,依次插入到头结点后面(头插法建立单链表),直到最后一个结点为止.

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520172204.png)

```c++
//方法一:时间复杂度O(n),空间复杂度O(1)
void listReverse1(LinkList &L)
{
	LNode *p=L->next;
	LNode *r=NULL;
	L->next=NULL;
	while(p!=NULL)
	{
		r=p->next;//记录p->next
		p->next=L->next;//头插法
		L->next=p;	
		p=r;//移动p
	}
}
```

方法二:依次遍历单链表,并将结点指针反转.

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520173753.png)

```c++
//方法二2:时间复杂度O(n),空间复杂度O(1)
void listReverse2(LinkList &L)
{
	LNode *pre;
	LNode *p=L->next;
	LNode *r=p->next;
	p->next=NULL;//因为第一个结点最后会变成尾结点所以p->next=NULL
	while(r!=NULL)//r为空,则说明p为最后一个结点
	{
		pre=p;//三个点都往后移动一位
		p=r;
		r=r->next;
		p->next=pre;//指针反转
	}
	L->next=p;
}
```

## main.cpp

```c++
#include "LinkList.h"
 
int main()
{
/*
	cout<<"listHeadInsert:"<<endl;
	LinkList H;
	listHeadInsert(H);
	listPrint(H);
*/
	cout<<"listHeadInsert:"<<endl;
	LinkList T;
	listTailInsert(T);
	cout<<"list T:"<<endl;
	listPrint(T);

	cout<<"Is empty::"<<listEmpty(T)<<endl;

	LNode *s=listGetElm(T,4);
	cout<<"4th:";
	if(s==NULL)
		cout<<"Error!"<<endl;
	else
		cout<<s->data<<endl;

	cout<<"where is 4:";
	int i=listLocateElm(T,4);
	if(i==0)
		cout<<"No find!"<<endl;
	else
		cout<<i<<endl;

	cout<<"Insert 3 after 3:"<<endl;
	int j=listBackInsert(T,3,3);
	if(j==0)
		cout<<"Error!"<<endl;
	listPrint(T);

	cout<<"length:"<<listLength(T)<<endl;

	cout<<"Reverse:"<<endl;
	listReverse1(T);
	listPrint(T);
	
	cout<<"Reverse again:"<<endl;
	listReverse2(T);
	listPrint(T);

	listDestory(T);
	return 0;
}
```

控制台结果:

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520191453.png)

# 二、概念

## 1.引入头结点的两个优点

- 链表的第一个位置和其他位置的操作(特别是插入和删除操作)统一
- 空表和非空表的操作统一

## 2.顺序表和链表的比较

|         角度         |                            顺序表                            |                             链表                             |
| :------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|       存取方式       |                  可以实现顺序存取和随机存取                  |                       只能实现顺序存取                       |
|  逻辑结构和物理结构  |          逻辑相邻物理上也相邻,通过相邻表示逻辑关系           |        逻辑相邻物理上不一定相邻,通过指针表示逻辑关系         |
| 查找、插入和删除操作 | 【插入&删除:O(n)且需要大量移动元素】【查找:按值查找:(无序)O(n),(有序)O(log~2~n);按序号查找:O(1)】 | 【插入&删除:O(1)(结点指针已知),O(n)(结点指针未知),但操作时只需修改相关指针】【查找:按值查找:O(n);;按序号查找:O(n)】 |
|       空间分配       | 预先分配:静态分配--太大浪费,太小溢出;动态分配--不会溢出但扩充需要大量移动元素,操作效率低 |           需要时分配,高效方便,但指针要使用额外空间           |

## 3.怎样选择线性表的存储结构

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520231726.png)