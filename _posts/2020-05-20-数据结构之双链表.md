---
layout:     post
title:      手撕数据结构——双链表
subtitle:   双链表
date:       2020-05-20
author:     wukurua
header-img: img/DS/post-bg-ds.png
catalog: true
tags:
    - Data Structure
---

# 一、代码

## DLinkList.h

```c++
#ifndef DLinkList_H
#define DLinkList_H
#include<iostream>
using namespace std;

typedef struct DNode
{
	int data;
	struct DNode *prior,*next;
}DNode,*DLinkList;

/*有头结点*/
//头插法
void listHeadInsert(DLinkList &L);
//尾插法
void listTailInsert(DLinkList &L);
//按序号查找
DNode *listGetElm(DLinkList &L,int i);
//按值查找
int listLocateElm(DLinkList &L,int e);
//插入结点--前插法
bool listFrontInsert(DLinkList &L,int i,int e);
bool listFrontInsert(DLinkList &L,DNode *ai,int e);
//插入结点--后插法
bool listBackInsert(DLinkList &L,int i,int e);
bool listBackInsert(DLinkList &L,DNode *ai,int e);
//删除结点
bool listDelete(DLinkList &L,int i);
//遍历结点
void listPrint(DLinkList &L);
//求表长
int listLength(DLinkList &L);
//是否为空
bool listEmpty(DLinkList &L);
//销毁链表
void listDestory(DLinkList &L);
//逆置链表
void listReverse1(DLinkList &L);
void listReverse2(DLinkList &L);

#endif
```

## DLinkList.cpp

可以把双链表看作是两个数据元素相同的单链表的融合,其中,一个由表头依次指向表尾(带有头结点),另一个由表尾依次指向表头(不带有头结点),所以在双链表的**表尾**插入结点/删除结点和其他部分插入节点/删除结点的操作存在差异性.

### 头插法

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520155919.png" style="zoom: 50%;" />

```c++
//时间复杂度O(n)
void listHeadInsert(DLinkList &L)
{
	L=(DLinkList)malloc(sizeof(DNode));
	L->next=NULL;
	L->prior=NULL;
	L->data=NULL;
	DNode *s;
	int x;
	scanf("%d",&x);
	while(x!=9999)
	{
		s=(DNode*)malloc(sizeof(DNode));
		s->data=x;
		s->next=L->next;//1
		L->next->prior=L;//2
		s->prior=L;//3
		L->next=s;//4
		scanf("%d",&x);
	}
}
```

### 尾插法

```c++
//时间复杂度O(n)--有尾指针情况下
void listTailInsert(DLinkList &L)
{
	L=(DLinkList)malloc(sizeof(DNode));
	L->next=NULL;
	L->data=NULL;
	DNode *s,*r=L;
	int x;
	scanf("%d",&x);
	while(x!=9999)
	{
		s=(DNode*)malloc(sizeof(DNode));
		s->data=x;
		s->prior=r;
		s->next=NULL;
		r->next=s;
		r=s;
		scanf("%d",&x);
	}
}
```

### 按序号查找&按值查找

```c++
//时间复杂度O(n)
DNode *listGetElm(DLinkList &L,int i)
{
	int j=1;
	DNode *p=L->next;
	if(i<0)
		return NULL;
	else if(i==0)
		return L;
	while(p&&j<i)
	{
		p=p->next;	
		j++;
	}
	return p;
}

int listLocateElm(DLinkList &L,int e)
{
	DNode *p=L->next;
	int i=1;
	while(p&&p->data!=e)
	{
		p=p->next;
		i++;
	}
	if(p==NULL)
		return 0;
	else
		return i;
}
```

### 插入结点

前插法:

```c++
//前插法(未知ai结点的位置)--时间复杂度O(n)
bool listFrontInsert(DLinkList &L,int i,int e)
{
	DNode *p=listGetElm(L,i-1);
	if(p==NULL)
		return false;
	DNode *s=(DNode*)malloc(sizeof(DNode));
	s->data=e;
	s->next=p->next;
	p->next->prior=s;
	s->prior=p;
	p->next=s;
	return true;
}

//前插法(已知ai结点的位置)--时间复杂度O(1)
bool listFrontInsert(DLinkList &L,DNode *ai,int e)
{
	DNode *p=ai->prior;
	if(p==NULL)
		return false;
	DNode *s=(DNode*)malloc(sizeof(DNode));
	s->data=e;
	s->next=p->next;
	p->next=s;
	return true;
}
```

后插法:

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520220234.png" style="zoom: 80%;" />

必须保证:==1,2步在4步前(为了不断链)==

```c++
//后插法(未知ai结点的位置)--时间复杂度O(n)
bool listBackInsert(DLinkList &L,int i,int e)
{
	DNode *p=listGetElm(L,i);
	if(p==NULL)
		return false;
	DNode *s=(DNode*)malloc(sizeof(DNode));
	s->data=e;
	s->next=NULL;
	if(p->next!=NULL)
	{
		s->next=p->next;//1	
		p->next->prior=s;//2
	}
	s->prior=p;//3
	p->next=s;//4
	return true;
}

//后插法(已知ai结点的位置)--时间复杂度O(1)
bool listBackInsert(DLinkList &L,DNode *ai,int e)
{
	DNode *p=ai;
	if(p==NULL)
		return false;
	DNode *s=(DNode*)malloc(sizeof(DNode));
	s->data=e;
	s->next=NULL;
	if(p->next!=NULL)
	{
		s->next=p->next;//1	
		p->next->prior=s;//2
	}
	s->prior=p;//3
	p->next=s;//4
	return true;
}
```

### 删除结点

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520220556.png" style="zoom:80%;" />

```c++
//时间复杂度O(n)
bool listDelete(DLinkList &L,int i)
{
	DNode *q=listGetElm(L,i);
	if(q==NULL)
		return false;
	DNode *p=q->prior;
	if(q->next!=NULL)
	{	
		p->next=q->next;
		q->next->prior=p;
	}
	else
	{
		p->next=NULL;
	}
	free(q);
	return true;
}
```

### 遍历结点&求表长

```c++
//时间复杂度O(n)	
void listPrint(DLinkList &L)
{
	DNode *p=L;
	while(p->next!=NULL)
	{
		printf("%d ",p->next->data);
		p=p->next;
	}
	printf("\n");
}

//时间复杂度O(n)
int listLength(DLinkList &L)
{
	int count=0;
	DNode *p=L;
	while(p->next!=NULL)
	{
		count++;
		p=p->next;
	}
	return count;
}
```

### 是否为空

```c++
bool listEmpty(DLinkList &L)
{
	if(L->next==NULL)
		return true;
	else
		return false;
}
```

### 销毁链表

```c++
void listDestory(DLinkList &L)
{
	DNode *p=L;
	DNode *q=NULL;
	while(p)
	{
		q=p->next;
		free(p);
		p=q;
	}
}
```

### 逆置链表

```c++
//方法一:时间复杂度O(n),空间复杂度O(1)
void listReverse1(DLinkList &L)
{
	DNode *p=L->next;
	DNode *r=NULL;
	L->next=NULL;
	while(p!=NULL)
	{
		r=p->next;//记录p->next
		p->next=L->next;//头插法
		L->next=p;	
		p=r;//移动p
	}
}

//方法二2:时间复杂度O(n),空间复杂度O(1)
void listReverse2(DLinkList &L)
{
	DNode *pre;
	DNode *p=L->next;
	DNode *r=p->next;
	p->next=NULL;//因为第一个结点最后会变成尾结点所以p->next=NULL
	while(r!=NULL)//r为空,则说明p为最后一个结点
	{
		pre=p;//三个点都往后移动一位
		p=r;
		r=r->next;
		p->next=pre;//指针反转
	}
	L->next=p;
}
```

## main.cpp

```c++
#include "DLinkList.h"
 
int main()
{
/*
	cout<<"listHeadInsert:"<<endl;
	LinkList H;
	listHeadInsert(H);
	listPrint(H);
*/
	cout<<"listHeadInsert:"<<endl;
	DLinkList T;
	listTailInsert(T);
	cout<<"list T:"<<endl;
	listPrint(T);

	cout<<"Is empty::"<<listEmpty(T)<<endl;

	DNode *s=listGetElm(T,4);
	cout<<"4th:";
	if(s==NULL)
		cout<<"Error!"<<endl;
	else
		cout<<s->data<<endl;

	cout<<"where is 4:";
	int i=listLocateElm(T,4);
	if(i==0)
		cout<<"No find!"<<endl;
	else
		cout<<i<<endl;

	cout<<"Insert 3 after 3:"<<endl;
	int j=listBackInsert(T,3,3);
	if(j==0)
		cout<<"Error!"<<endl;
	listPrint(T);

	cout<<"length:"<<listLength(T)<<endl;

	cout<<"Reverse:"<<endl;
	listReverse1(T);
	listPrint(T);
	
	cout<<"Reverse again:"<<endl;
	listReverse2(T);
	listPrint(T);

	cout<<"Delete 4th:"<<endl;
	listDelete(T,4);
	listPrint(T);

	listDestory(T);
	return 0;
}
```

控制台结果:

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200520223833.png)
