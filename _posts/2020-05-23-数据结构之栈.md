---
layout:     post
title:      手撕数据结构——栈
subtitle:   顺序栈,共享栈,链栈
date:       2020-05-23
author:     wukurua
header-img: img/DS/post-bg-ds.png
catalog: true
tags:
    - Data Structure
---

# 一、栈的顺序存储结构——顺序栈

## SqStack.h

```c++
#ifndef SQSTACK_H
#define SQSTACK_H
#include<iostream>
using namespace std;

const int MaxSize=10;

typedef struct
{
	int data[MaxSize];
	int top;//栈顶指针
}SqStack;

void stackInit(SqStack &S);
bool stackEmpty(SqStack &S);
bool stackPush(SqStack &S,int e);
bool stackPop(SqStack &S,int &e);
bool stackGetTop(SqStack S,int &e);
void stackPrint(SqStack &S);

#endif
```

## SqStack.cpp

### 初始化时top=-1;

```c++
#include "SqStack.h"

void stackInit(SqStack &S)
{
	S.top=-1;//初始化
}

bool stackEmpty(SqStack &S)
{
	if(S.top==-1)
		return true;
	else
		return false;
}

bool stackPush(SqStack &S,int e)
{
	if(S.top==MaxSize-1)//栈满
		return false;
	S.data[++S.top]=e;
	return true;
}

bool stackPop(SqStack &S,int &e)
{
	if(S.top==-1)//栈空
		return false;
	e=S.data[S.top--];
	return true;
}

bool stackGetTop(SqStack S,int &e)
{
	if(S.top==-1)//栈空
		return false;
	e=S.data[S.top];
	return true;
}

void stackPrint(SqStack &S)
{
	for(int i=S.top;i>=0;i--)
		cout<<S.data[i]<<" ";
	cout<<endl;
}
```

### 初始化时top=0;

```c++
#include "SqStack.h"

void stackInit(SqStack &S)
{
	S.top=0;//初始化
}

bool stackEmpty(SqStack &S)
{
	if(S.top==0)
		return true;
	else
		return false;
}

bool stackPush(SqStack &S,int e)
{
	if(S.top==MaxSize)//栈满
		return false;
	S.data[S.top++]=e;
	return true;
}

bool stackPop(SqStack &S,int &e)
{
	if(S.top==0)//栈空
		return false;
	e=S.data[--S.top];
	return true;
}

bool stackGetTop(SqStack S,int &e)
{
	if(S.top==0)//栈空
		return false;
	e=S.data[S.top-1];
	return true;
}

void stackPrint(SqStack &S)
{
	for(int i=S.top-1;i>=0;i--)
		cout<<S.data[i]<<" ";
	cout<<endl;
}
```

## main.cpp

```c++
#include "SqStack.h"
 
int main()
{
	SqStack S;
	stackInit(S);

	cout<<"isEmpty:"<<stackEmpty(S)<<endl;

	cout<<"Push:";
	stackPush(S,1);
	stackPush(S,2);
	stackPush(S,3);
	stackPush(S,4);
	stackPrint(S);

	cout<<"Pop:";
	int e;
	stackPop(S,e);
	stackPrint(S);

	stackGetTop(S,e);
	cout<<"getTop:"<<e<<endl;

	cout<<"isEmpty:"<<stackEmpty(S)<<endl;

	return 0;
}
```

控制台结果:

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200523004020.png)

# 二、栈的顺序存储结构——共享栈

## SqStack.h

```c++
typedef struct
{
	int data[MaxSize];
	int top0;//0号栈栈顶指针
	int top1;//1号栈栈顶指针
	int choose;//看作一个按钮,每次push或pop操作,就toggle一下按钮
}SqStack;
```

其余部分与上面内容一致.

## SqStack.cpp

```c++
#include "SqStack.h"

void stackInit(SqStack &S)
{
	S.top0=-1;//初始化
	S.top1=MaxSize;
	S.choose=0;
}

bool stackEmpty(SqStack &S)
{
	if(S.top0==-1||S.top1==MaxSize)
		return true;
	else
		return false;
}

bool stackPush(SqStack &S,int e)
{
	if(S.top0+1==S.top1)//栈满
		return false;
	if(S.choose)
	{
		S.data[++S.top0]=e;
		S.choose=0;
	}	
	else
	{
		S.data[--S.top1]=e;
		S.choose=1;
	}
	return true;
}

bool stackPop(SqStack &S,int &e)
{
	if(S.top0==-1||S.top1==MaxSize)//栈空
		return false;
	if(S.choose)
	{
		e=S.data[S.top0--];
		S.choose=0;
	}
	else
	{
		e=S.data[S.top1++];	
		S.choose=1;
	}
	return true;
}

bool stackGetTop(SqStack S,int &e0,int &e1)
{
	if(S.top0==-1||S.top1==MaxSize)//栈空
		return false;
	e0=S.data[S.top0-1];
	e1=S.data[S.top1+1];
	return true;
}

void stackPrint(SqStack &S)
{
	cout<<"栈底端从顶到底排列:";
	for(int i=S.top0;i>=0;i--)
		cout<<S.data[i]<<" ";
	cout<<endl;

	cout<<"栈顶端从底到顶排列:";
	for(int j=S.top1;j<MaxSize;j++)
		cout<<S.data[j]<<" ";
	cout<<endl;
}
```

## main.cpp

```c++
#include "SqStack.h"
 
int main()
{
	SqStack S;
	stackInit(S);

	cout<<"isEmpty:"<<stackEmpty(S)<<endl;

	cout<<"Push:";
	stackPush(S,1);
	stackPush(S,2);
	stackPush(S,3);
	stackPush(S,4);
	stackPrint(S);
	cout<<endl;

	cout<<"Pop:";
	int e0,e1;
	stackPop(S,e0);
	stackPrint(S);
	cout<<endl;

	stackGetTop(S,e0,e1);
	cout<<"getTop:"<<e0<<" "<<e1<<endl;

	cout<<"isEmpty:"<<stackEmpty(S)<<endl;

	return 0;
}
```

控制台结果:

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200523012129.png)

# 三、栈的链式存储结构——链栈

## LiStack.h

```c++
#ifndef LiStack_H
#define LiStack_H
#include<iostream>
using namespace std;


typedef struct LNode
{
	int data;
	struct LNode *next;
}LNode,*LiStack;

void stackInit(LiStack &S);
bool stackEmpty(LiStack &S);
bool stackPush(LiStack &S,int e);
bool stackPop(LiStack &S,int &e);
bool stackGetTop(LiStack S,int &e);
void stackPrint(LiStack &S);
void stackDestory(LiStack &S);

#endif
```

## LiStack.cpp

### 不带头结点

```c++
#include "LiStack.h"
//不带头结点
void stackInit(LiStack &S)
{
	S=NULL;
}

bool stackEmpty(LiStack &S)
{
	if(S==NULL)
		return true;
	else
		return false;
}

bool stackPush(LiStack &S,int e)
{
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=e;
	s->next=NULL;
	if(S==NULL)
	{
		S=s;
	}
	else
	{
		s->next=S;
		S=s;
	}
	return true;
}

bool stackPop(LiStack &S,int &e)
{
	if(S==NULL)//栈空
		return false;
	LNode *p=S;
	LNode *s=S;
	e=S->data;
	p=p->next;
	free(s);
	S=p;
	return true;
}

bool stackGetTop(LiStack S,int &e)
{
	if(S==NULL)//栈空
		return false;
	e=S->data;
	return true;
}

void stackPrint(LiStack &S)
{
	LNode *p=S;
	while(p!=NULL)
	{
		cout<<p->data<<" ";
		p=p->next;
	}
	cout<<endl;
}

void stackDestory(LiStack &S)
{
	LNode *p=S;
	LNode *s=S;
	while(p!=NULL)
	{
		s=p;
		p=p->next;
		free(s);
	}
}
```

### 带头结点

```c++
#include "LiStack.h"
//带头结点
void stackInit(LiStack &S)
{
	S=(LiStack)malloc(sizeof(LNode));
	S->next=NULL;
	S->data=NULL;
}

bool stackEmpty(LiStack &S)
{
	if(S->next=NULL)
		return true;
	else
		return false;
}

bool stackPush(LiStack &S,int e)
{
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=e;
	s->next=NULL;
	if(S->next==NULL)
	{
		S->next=s;
	}
	else
	{
		LNode *p=S;
		s->next=p->next;
		p->next=s;
	}
	return true;
}

bool stackPop(LiStack &S,int &e)
{
	if(S->next==NULL)//栈空
		return false;
	LNode *p=S;
	LNode *q=S->next;
	p->next=q->next;
	e=q->data;
	free(q);
	return true;
}

bool stackGetTop(LiStack S,int &e)
{
	if(S->next==NULL)//栈空
		return false;
	e=S->next->data;
	return true;
}

void stackPrint(LiStack &S)
{
	LNode *p=S->next;
	while(p!=NULL)
	{
		cout<<p->data<<" ";
		p=p->next;
	}
	cout<<endl;
}

void stackDestory(LiStack &S)
{
	LNode *p=S;
	LNode *s=S;
	while(p!=NULL)
	{
		s=p;
		p=p->next;
		free(s);
	}
}
```

## main.cpp

```c++
#include "LiStack.h"
 
int main()
{
	LiStack S;
	stackInit(S);

	cout<<"isEmpty:"<<stackEmpty(S)<<endl;

	cout<<"Push:";
	stackPush(S,1);
	stackPush(S,2);
	stackPush(S,3);
	stackPush(S,4);
	stackPrint(S);

	cout<<"Pop:";
	int e;
	stackPop(S,e);
	stackPrint(S);

	stackGetTop(S,e);
	cout<<"getTop:"<<e<<endl;

	cout<<"isEmpty:"<<stackEmpty(S)<<endl;

	stackDestory(S);
	return 0;
}
```

控制台结果和上面顺序栈的一致.

# 四、应用举例

## 1.括号匹配

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200528204926.png)

```c++
#include<iostream>
#include<string>
#include<stack>
using namespace std;

bool breactChecker(string str)
{
	stack<char> S;
	int len=str.length();
	for(int i=0;i<len;i++)
	{
		char e=str.at(i);
		if(e=='('||e=='{'||e=='[')
		{
			S.push(e);
		}
		else
		{
			if(S.empty())//右括号单身
				return false;
			char topElem=S.top();
			S.pop();
			//左右括号不配对
			if(e==')'&&topElem!='(')
				return false;
			if(e=='}'&&topElem!='{')
				return false;
			if(e==']'&&topElem!='[')
				return false;
		}
	}
	if(S.empty())//左括号单身
		return true;
	else
		return false;
}
int main()
{
	cout<<"(()){[]} res:"<<breactChecker("(()){[]}")<<endl;
	cout<<"(()))) res:"<<breactChecker("(())))")<<endl;
	cout<<"((() res:"<<breactChecker("((()")<<endl;
	cout<<"(({]) res:"<<breactChecker("(({])")<<endl;
	return 0;
}
```

控制台结果:

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200528211315.png)

## 2.中缀表达式转换为后缀表达式求值

> 后缀表达式也称逆波兰表达式
>
> 表达式规则:运算符在两个操作数后面

由算法的确定性,执行==左优先原则==,即只要左边的运算符能先计算,就优先算左边的,来保证计算结果相同

**(1)中缀表达式转换成后缀表达式的算法实现:**

初始化一个栈用来保存**暂时还不能确定运算顺序的运算符**.

==从左向右==扫描下一个元素,直到处理完所有元素,可能遇到3种情况:

1. 遇到操作数,直接加入后缀表达式

2. 遇到界限符,如果为**"("直接入栈,")"则依次弹出栈内运算符并加入后缀表达式,直到弹出"("为止**(注意:"("不加入后缀表达式)

3. 遇到运算符,则依次弹出栈中优先级==高于或等于==当前运算符的所有运算符,并加入后缀表达式.若碰到"("或栈空则停止,把当前运算符入栈

   按上述方法处理完所有字符后,将栈中剩余运算符依次弹出,并加入后缀表达式.

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/GIF 2020-5-28 23-17-36.gif)

**(2)后缀表达式求值的算法实现:**

1. ==从左向右==扫描下一个元素,直到处理完所有元素
2. 若扫描到操作数则压入栈,并回到1;否则执行3
3. 若扫描到运算符,则弹出两个栈顶元素(==先出栈的是右操作数==),执行相应运算,运算结果压回栈顶,回到1

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/GIF 2020-5-29 0-14-29.gif)

**(3)结合两个算法:**

初始化两个栈,==操作数栈==和==运算符栈==

若扫描到操作数,压入操作数栈

若扫描到运算符或界限符,则按照"中缀转后缀"相同的逻辑压入运算符栈(期间也会弹出运算符,**每当弹出一个运算符时,就需要再弹出两个操作数栈的栈顶元素并执行相应运算,运算结果再压回操作数栈**)

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/GIF 2020-5-29 0-27-38.gif)



> 另外还有**前缀表达式**,也称波兰表达式,规则:运算符在两个操作数前面
>
> 执行==右优先原则==,即只要右边的运算符能先计算,就优先算右边的
>
> 它的计算算法实现与后缀不同点:==从右向左==扫描元素,弹出两个栈顶元素时==先出栈的是左操作数==

## 3.栈的递归实现

