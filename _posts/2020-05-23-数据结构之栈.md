---
layout:     post
title:      手撕数据结构——栈
subtitle:   顺序栈,共享栈,链栈
date:       2020-05-23
author:     wukurua
header-img: img/DS/post-bg-ds.png
catalog: true
tags:
    - Data Structure
---

# 一、栈的顺序存储结构——顺序栈

## SqStack.h

```c++
#ifndef SQSTACK_H
#define SQSTACK_H
#include<iostream>
using namespace std;

const int MaxSize=10;

typedef struct
{
	int data[MaxSize];
	int top;//栈顶指针
}SqStack;

void stackInit(SqStack &S);
bool stackEmpty(SqStack &S);
bool stackPush(SqStack &S,int e);
bool stackPop(SqStack &S,int &e);
bool stackGetTop(SqStack S,int &e);
void stackPrint(SqStack &S);

#endif
```

## SqStack.cpp

### 初始化时top=-1;

```c++
#include "SqStack.h"

void stackInit(SqStack &S)
{
	S.top=-1;//初始化
}

bool stackEmpty(SqStack &S)
{
	if(S.top==-1)
		return true;
	else
		return false;
}

bool stackPush(SqStack &S,int e)
{
	if(S.top==MaxSize-1)//栈满
		return false;
	S.data[++S.top]=e;
	return true;
}

bool stackPop(SqStack &S,int &e)
{
	if(S.top==-1)//栈空
		return false;
	e=S.data[S.top--];
	return true;
}

bool stackGetTop(SqStack S,int &e)
{
	if(S.top==-1)//栈空
		return false;
	e=S.data[S.top];
	return true;
}

void stackPrint(SqStack &S)
{
	for(int i=S.top;i>=0;i--)
		cout<<S.data[i]<<" ";
	cout<<endl;
}
```

### 初始化时top=0;

```c++
#include "SqStack.h"

void stackInit(SqStack &S)
{
	S.top=0;//初始化
}

bool stackEmpty(SqStack &S)
{
	if(S.top==0)
		return true;
	else
		return false;
}

bool stackPush(SqStack &S,int e)
{
	if(S.top==MaxSize)//栈满
		return false;
	S.data[S.top++]=e;
	return true;
}

bool stackPop(SqStack &S,int &e)
{
	if(S.top==0)//栈空
		return false;
	e=S.data[--S.top];
	return true;
}

bool stackGetTop(SqStack S,int &e)
{
	if(S.top==0)//栈空
		return false;
	e=S.data[S.top-1];
	return true;
}

void stackPrint(SqStack &S)
{
	for(int i=S.top-1;i>=0;i--)
		cout<<S.data[i]<<" ";
	cout<<endl;
}
```

## main.cpp

```c++
#include "SqStack.h"
 
int main()
{
	SqStack S;
	stackInit(S);

	cout<<"isEmpty:"<<stackEmpty(S)<<endl;

	cout<<"Push:";
	stackPush(S,1);
	stackPush(S,2);
	stackPush(S,3);
	stackPush(S,4);
	stackPrint(S);

	cout<<"Pop:";
	int e;
	stackPop(S,e);
	stackPrint(S);

	stackGetTop(S,e);
	cout<<"getTop:"<<e<<endl;

	cout<<"isEmpty:"<<stackEmpty(S)<<endl;

	return 0;
}
```

控制台结果:

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200523004020.png)

# 二、栈的顺序存储结构——共享栈

## SqStack.h

```c++
typedef struct
{
	int data[MaxSize];
	int top0;//0号栈栈顶指针
	int top1;//1号栈栈顶指针
	int choose;//看作一个按钮,每次push或pop操作,就toggle一下按钮
}SqStack;
```

其余部分与上面内容一致.

## SqStack.cpp

```c++
#include "SqStack.h"

void stackInit(SqStack &S)
{
	S.top0=-1;//初始化
	S.top1=MaxSize;
	S.choose=0;
}

bool stackEmpty(SqStack &S)
{
	if(S.top0==-1||S.top1==MaxSize)
		return true;
	else
		return false;
}

bool stackPush(SqStack &S,int e)
{
	if(S.top0+1==S.top1)//栈满
		return false;
	if(S.choose)
	{
		S.data[++S.top0]=e;
		S.choose=0;
	}	
	else
	{
		S.data[--S.top1]=e;
		S.choose=1;
	}
	return true;
}

bool stackPop(SqStack &S,int &e)
{
	if(S.top0==-1||S.top1==MaxSize)//栈空
		return false;
	if(S.choose)
	{
		e=S.data[S.top0--];
		S.choose=0;
	}
	else
	{
		e=S.data[S.top1++];	
		S.choose=1;
	}
	return true;
}

bool stackGetTop(SqStack S,int &e0,int &e1)
{
	if(S.top0==-1||S.top1==MaxSize)//栈空
		return false;
	e0=S.data[S.top0-1];
	e1=S.data[S.top1+1];
	return true;
}

void stackPrint(SqStack &S)
{
	cout<<"栈底端从顶到底排列:";
	for(int i=S.top0;i>=0;i--)
		cout<<S.data[i]<<" ";
	cout<<endl;

	cout<<"栈顶端从底到顶排列:";
	for(int j=S.top1;j<MaxSize;j++)
		cout<<S.data[j]<<" ";
	cout<<endl;
}
```

## main.cpp

```c++
#include "SqStack.h"
 
int main()
{
	SqStack S;
	stackInit(S);

	cout<<"isEmpty:"<<stackEmpty(S)<<endl;

	cout<<"Push:";
	stackPush(S,1);
	stackPush(S,2);
	stackPush(S,3);
	stackPush(S,4);
	stackPrint(S);
	cout<<endl;

	cout<<"Pop:";
	int e0,e1;
	stackPop(S,e0);
	stackPrint(S);
	cout<<endl;

	stackGetTop(S,e0,e1);
	cout<<"getTop:"<<e0<<" "<<e1<<endl;

	cout<<"isEmpty:"<<stackEmpty(S)<<endl;

	return 0;
}
```

控制台结果:

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200523012129.png)

# 三、栈的链式存储结构——链栈

## LiStack.h

```c++
#ifndef LiStack_H
#define LiStack_H
#include<iostream>
using namespace std;


typedef struct LNode
{
	int data;
	struct LNode *next;
}LNode,*LiStack;

void stackInit(LiStack &S);
bool stackEmpty(LiStack &S);
bool stackPush(LiStack &S,int e);
bool stackPop(LiStack &S,int &e);
bool stackGetTop(LiStack S,int &e);
void stackPrint(LiStack &S);
void stackDestory(LiStack &S);

#endif
```

## LiStack.cpp

### 不带头结点

```c++
#include "LiStack.h"
//不带头结点
void stackInit(LiStack &S)
{
	S=NULL;
}

bool stackEmpty(LiStack &S)
{
	if(S==NULL)
		return true;
	else
		return false;
}

bool stackPush(LiStack &S,int e)
{
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=e;
	s->next=NULL;
	if(S==NULL)
	{
		S=s;
	}
	else
	{
		s->next=S;
		S=s;
	}
	return true;
}

bool stackPop(LiStack &S,int &e)
{
	if(S==NULL)//栈空
		return false;
	LNode *p=S;
	LNode *s=S;
	e=S->data;
	p=p->next;
	free(s);
	S=p;
	return true;
}

bool stackGetTop(LiStack S,int &e)
{
	if(S==NULL)//栈空
		return false;
	e=S->data;
	return true;
}

void stackPrint(LiStack &S)
{
	LNode *p=S;
	while(p!=NULL)
	{
		cout<<p->data<<" ";
		p=p->next;
	}
	cout<<endl;
}

void stackDestory(LiStack &S)
{
	LNode *p=S;
	LNode *s=S;
	while(p!=NULL)
	{
		s=p;
		p=p->next;
		free(s);
	}
}
```

### 带头结点

```c++
#include "LiStack.h"
//带头结点
void stackInit(LiStack &S)
{
	S=(LiStack)malloc(sizeof(LNode));
	S->next=NULL;
	S->data=NULL;
}

bool stackEmpty(LiStack &S)
{
	if(S->next=NULL)
		return true;
	else
		return false;
}

bool stackPush(LiStack &S,int e)
{
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=e;
	s->next=NULL;
	if(S->next==NULL)
	{
		S->next=s;
	}
	else
	{
		LNode *p=S;
		s->next=p->next;
		p->next=s;
	}
	return true;
}

bool stackPop(LiStack &S,int &e)
{
	if(S->next==NULL)//栈空
		return false;
	LNode *p=S;
	LNode *q=S->next;
	p->next=q->next;
	e=q->data;
	free(q);
	return true;
}

bool stackGetTop(LiStack S,int &e)
{
	if(S->next==NULL)//栈空
		return false;
	e=S->next->data;
	return true;
}

void stackPrint(LiStack &S)
{
	LNode *p=S->next;
	while(p!=NULL)
	{
		cout<<p->data<<" ";
		p=p->next;
	}
	cout<<endl;
}

void stackDestory(LiStack &S)
{
	LNode *p=S;
	LNode *s=S;
	while(p!=NULL)
	{
		s=p;
		p=p->next;
		free(s);
	}
}
```

## main.cpp

```c++
#include "LiStack.h"
 
int main()
{
	LiStack S;
	stackInit(S);

	cout<<"isEmpty:"<<stackEmpty(S)<<endl;

	cout<<"Push:";
	stackPush(S,1);
	stackPush(S,2);
	stackPush(S,3);
	stackPush(S,4);
	stackPrint(S);

	cout<<"Pop:";
	int e;
	stackPop(S,e);
	stackPrint(S);

	stackGetTop(S,e);
	cout<<"getTop:"<<e<<endl;

	cout<<"isEmpty:"<<stackEmpty(S)<<endl;

	stackDestory(S);
	return 0;
}
```

控制台结果和上面顺序栈的一致.

