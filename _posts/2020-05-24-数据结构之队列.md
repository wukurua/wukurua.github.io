---
layout:     post
title:      手撕数据结构——队列
subtitle:   顺序实现的三个方案,链式实现,双端队列
date:       2020-05-24
author:     wukurua
header-img: img/DS/post-bg-ds.png
catalog: true
tags:
    - Data Structure
---

# 一、队列的顺序实现

用模运算(取余)将存储空间在逻辑上变成**"环状"**-->**循环队列**

对于如何**区分队空还是队满**的情况,有三种处理方式:

## 方案一:牺牲一个单位来区分队空和队满

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200523233804.png" style="zoom: 50%;" />

### SqQueue.h

```c++
#ifndef SQQUEUE_H
#define SQQUEUE_H
#include<iostream>
using namespace std;

const int MaxSize=10;

typedef struct
{
	int data[MaxSize];
	int front,rear;//队尾指针指向队尾元素的后一个位置
}SqQueue;

void queueInit(SqQueue &Q);
bool queueEmpty(SqQueue &Q);
bool queueEn(SqQueue &Q,int e);
bool queueDe(SqQueue &Q,int &e);
bool queueGetHead(SqQueue Q,int &e);
void queuePrint(SqQueue &Q);
int queueCount(SqQueue &Q);

#endif
```

### SqQueue.cpp

```c++
#include "SqQueue.h"

void queueInit(SqQueue &Q)
{
	Q.front=Q.rear=0;
}

bool queueEmpty(SqQueue &Q)
{
	if(Q.front==Q.rear)//空队列
		return true;
	else
		return false;
}

bool queueEn(SqQueue &Q,int e)
{
	if((Q.rear+1)%MaxSize==Q.front)//队满
		return false;
	Q.data[Q.rear]=e;
	Q.rear=(Q.rear+1)%MaxSize;
	return true;
}

bool queueDe(SqQueue &Q,int &e)
{
	if(Q.front==Q.rear)//空队列
		return false;
	e=Q.data[Q.front];
	Q.front=(Q.front+1)%MaxSize;
	return true;
}

bool queueGetHead(SqQueue Q,int &e)
{
	if(Q.front==Q.rear)//空队列
		return false;
	e=Q.data[Q.front];
	return true;
}

void queuePrint(SqQueue &Q)
{
	for(int i=Q.front;i<Q.rear;i++)
		cout<<Q.data[i]<<" ";
	cout<<endl;
}

int queueCount(SqQueue &Q)
{
	return (Q.rear+MaxSize-Q.front)%MaxSize;//队列元素个数
}
```

### main.cpp

```c++
#include "SqQueue.h"
 
int main()
{
	SqQueue Q;
	queueInit(Q);

	cout<<"isEmpty:"<<queueEmpty(Q)<<endl;

	cout<<"En:";
	queueEn(Q,1);
	queueEn(Q,2);
	queueEn(Q,3);
	queueEn(Q,4);
	queuePrint(Q);
	cout<<endl;

	cout<<"De:";
	int e;
	queueDe(Q,e);
	queuePrint(Q);
	cout<<endl;

	queueGetHead(Q,e);
	cout<<"getHead:"<<e<<" "<<endl;
	cout<<"Count:"<<queueCount(Q)<<endl;

	cout<<"isEmpty:"<<queueEmpty(Q)<<endl;

	return 0;
}
```

控制台结果:

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200524000226.png)

## 方案二:类型中增设表示元素个数的数据成员

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200524005544.png" style="zoom:50%;" />

### SqQueue.h

```c++
typedef struct
{
	int data[MaxSize];
	int front,rear;
	int size;//队列当前长度
}SqQueue;
```

### SqQueue.cpp

```c++
#include "SqQueue.h"

void queueInit(SqQueue &Q)
{
	Q.front=Q.rear=0;
	Q.size=0;
}

bool queueEmpty(SqQueue &Q)
{
	if(Q.size==0)//空队列
		return true;
	else
		return false;
}

bool queueEn(SqQueue &Q,int e)
{
	if(Q.size==MaxSize)//队满
		return false;
	Q.data[Q.rear]=e;
	Q.rear=(Q.rear+1)%MaxSize;
	Q.size++;
	return true;
}

bool queueDe(SqQueue &Q,int &e)
{
	if(Q.size==0)//空队列
		return false;
	e=Q.data[Q.front];
	Q.front=(Q.front+1)%MaxSize;
	Q.size--;
	return true;
}

bool queueGetHead(SqQueue Q,int &e)
{
	if(Q.size==0)//空队列
		return false;
	e=Q.data[Q.front];
	return true;
}

void queuePrint(SqQueue &Q)
{
	for(int i=Q.front;i<=Q.rear;i++)
		cout<<Q.data[i]<<" ";
	cout<<endl;
}

int queueCount(SqQueue &Q)
{
	return Q.size;//队列元素个数
}
```

## 方案三:类型中增设tag数据成员来区别

思路：每次删除操作成功时,都令tag=0;每次插入操作成功时,都令tag=1.只有删除操作才可能导致队空,只有插入操作才可能导致队满.

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200524010403.png" style="zoom:50%;" />

### SqQueue.h

```c++
typedef struct
{
	int data[MaxSize];
	int front,rear;
	int size;//最近进行的是删除0/插入1操作
}SqQueue;
```

### SqQueue.cpp

```c++
#include "SqQueue.h"

void queueInit(SqQueue &Q)
{
	Q.front=Q.rear=0;
	Q.tag=0;
}

bool queueEmpty(SqQueue &Q)
{
	if(Q.front==Q.rear&&Q.tag==0)//空队列
		return true;
	else
		return false;
}

bool queueEn(SqQueue &Q,int e)
{
	if(Q.front==Q.rear&&Q.tag==1)//队满
		return false;
	Q.data[Q.rear]=e;
	Q.rear=(Q.rear+1)%MaxSize;
	Q.tag=1;
	return true;
}

bool queueDe(SqQueue &Q,int &e)
{
	if(Q.front==Q.rear&&Q.tag==0)//空队列
		return false;
	e=Q.data[Q.front];
	Q.front=(Q.front+1)%MaxSize;
	Q.tag=0;
	return true;
}

bool queueGetHead(SqQueue Q,int &e)
{
	if(Q.front==Q.rear&&Q.tag==0)//空队列
		return false;
	e=Q.data[Q.front];
	return true;
}

void queuePrint(SqQueue &Q)
{
	for(int i=Q.front;i<Q.rear;i++)
		cout<<Q.data[i]<<" ";
	cout<<endl;
}

int queueCount(SqQueue &Q)
{
	return (Q.rear+MaxSize-Q.front)%MaxSize;//队列元素个数
}
```



## 总结

### 如何判空,判满

|                   方案                   |           队空条件           |             队满条件              |
| :--------------------------------------: | :--------------------------: | :-------------------------------: |
|       牺牲一个单位来区分队空和队满       |     `Q.front == Q.rear`      | `(Q.rear + 1)%MaxSize == Q.front` |
|     类型中增设表示元素个数的数据成员     |        `Q.size == 0`         |        `Q.size == MaxSize`        |
| 类型中增设tag数据成员来区别(0删除,1插入) | `Q.front== Q.rear&&Q.tag==0` | `Q.front == Q.rear && Q.tag == 1` |

### 计算队列长度

`(Q.rear+MaxSize-Q.front)%MaxSize`

# 二、队列的链式存储结构

> 注意第一个元素入队和最后一个元素出队

## LinkQueue.h

```c++
#ifndef LINKQUEUE_H
#define LINKQUEUE_H
#include<iostream>
using namespace std;

typedef struct 
{
	int data;
	struct LNode *front,*rear;
}LinkQueue;

typedef struct LNode
{
	int data;
	struct LNode *next;
}LNode;

void queueInit(LinkQueue &Q);
bool queueEmpty(LinkQueue &Q);
bool queueEn(LinkQueue &Q,int e);
bool queueDe(LinkQueue &Q,int &e);
bool queueGetTop(LinkQueue Q,int &e);
void queuePrint(LinkQueue &Q);
void queueDestory(LinkQueue &Q);

#endif
```

## LinkQueue.cpp

### 带头结点:

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200528162136.png" style="zoom:50%;" />

```c++
void queueInit(LinkQueue &Q)
{
	Q.front=Q.rear=(LNode*)malloc(sizeof(LNode));
	Q.front->next=NULL;
}

bool queueEmpty(LinkQueue &Q)
{
	if(Q.front==Q.rear)//Q.front==NULL也行
		return true;
	else
		return false;
}

bool queueEn(LinkQueue &Q,int e)
{
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=e;
	s->next=NULL;
	Q.rear->next=s;
	Q.rear=s;
	return true;
}
```

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200528164055.png" style="zoom:67%;" />

```c++
bool queueDe(LinkQueue &Q,int &e)
{
	if(Q.front==Q.rear)//队空
		return false;
	LNode *p=Q.front->next;
	e=p->data;
	Q.front->next=p->next;
	if(Q.rear==p)
		Q.rear=Q.front;
	free(p);
	return true;
}

bool queueGetTop(LinkQueue Q,int &e)
{
	if(Q.front==Q.rear)//队空
		return false;
	e=Q.front->next->data;
	return true;
}

void queuePrint(LinkQueue &Q)
{
	LNode *p=Q.front->next;
	while(p!=NULL)
	{
		cout<<p->data<<" ";
		p=p->next;
	}
	cout<<endl;
}

void queueDestory(LinkQueue &Q)
{
	LNode *p=Q.front;
	LNode *s=Q.front;
	while(p!=NULL)
	{
		s=p;
		p=p->next;
		free(s);
	}
}
```

### 不带头结点:

```c++
void queueInit(LinkQueue &Q)
{
	Q.front=NULL;
	Q.rear=NULL;
}

bool queueEmpty(LinkQueue &Q)
{
	if(Q.front==NULL)//Q.rear==NULL也行
		return true;
	else
		return false;
}

bool queueEn(LinkQueue &Q,int e)
{
	LNode *s=(LNode*)malloc(sizeof(LNode));
	s->data=e;
	s->next=NULL;
	if(Q.front==NULL)
	{
		Q.front=s;
		Q.rear=s;
	}
	else
	{
		Q.rear->next=s;
		Q.rear=s;
	}
	return true;
}

bool queueDe(LinkQueue &Q,int &e)
{
	if(Q.front==NULL)//队空
		return false;
	LNode *p=Q.front;
	e=p->data;
	Q.front=p->next;
	if(Q.rear==p)
	{
		Q.rear=NULL;
		Q.front=NULL;
	}
	free(p);
	return true;
}

bool queueGetTop(LinkQueue Q,int &e)
{
	if(Q.front==NULL)//队空
		return false;
	e=Q.front->data;
	return true;
}

void queuePrint(LinkQueue &Q)
{
	LNode *p=Q.front;
	while(p!=NULL)
	{
		cout<<p->data<<" ";
		p=p->next;
	}
	cout<<endl;
}

void queueDestory(LinkQueue &Q)
{
	LNode *p=Q.front;
	LNode *s=Q.front;
	while(p!=NULL)
	{
		s=p;
		p=p->next;
		free(s);
	}
}
```

## main.cpp

```c++
#include "LinkQueue.h"
 
int main()
{
	LinkQueue Q;
	queueInit(Q);

	cout<<"isEmpty:"<<queueEmpty(Q)<<endl;

	cout<<"En:";
	queueEn(Q,1);
	queueEn(Q,2);
	queueEn(Q,3);
	queueEn(Q,4);
	queuePrint(Q);

	cout<<"De:";
	int e;
	queueDe(Q,e);
	queuePrint(Q);

	queueGetTop(Q,e);
	cout<<"getTop:"<<e<<endl;

	cout<<"isEmpty:"<<queueEmpty(Q)<<endl;

	queueDestory(Q);
	return 0;
}
```

控制台结果:

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200528165707.png)

# 三、双端队列

若**只使用其中一端**的插入、删除操作，则效果等同于**栈**,即栈中出现的合法输出序列,在双端队列中也一定是合法的.

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200528170429.png" style="zoom: 50%;" />

使用**卡特兰数**计算**合法的输出序列个数**,公式如下:
$$
\frac {1}{n+1} C {^n_{2n}}
$$


例如数据元素输入序列为1,2,3,4,则合法的输出序列个数为$\frac {1}{n+1} C {^n_{2n}} = \frac {1}{4+1} C {^4_8} = 14$

# 四、队列的应用

- 树的层次遍历

- 图的广度优先遍历

- 操作系统中先来先服务FCFS的策略实现

  