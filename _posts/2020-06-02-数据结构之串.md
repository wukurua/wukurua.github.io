---
layout:     post
title:      手撕数据结构——串
subtitle:   kMP算法
date:       2020-06-02
author:     wukurua
header-img: img/DS/post-bg-ds.png
catalog: true
tags:
    - Data Structure
---

# 一、串的顺序存储

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200602213955.png)

## SString.h

```c++
#ifndef SQSTACK_H
#define SQSTACK_H
#include<iostream>
using namespace std;

#define MAXLEN 255

typedef struct SString
{
	char ch[MAXLEN];
	int length;
}SString;

void strInit(SString &S);
void strAssign(SString &T,char *str);
void strCopy(SString &T,SString S);
bool strEmpty(SString S);
int strLength(SString S);
void strPrint(SString S);
void strClear(SString &S);
bool strSub(SString &Sub,SString &S,int pos,int len);//求子串
int strCompare(SString S,SString T);
bool strConcat(SString &T,SString S1,SString S2);
int strIndex(SString S,SString T);//定位主串S中的子串T第一次出现的位置

#endif
```

## SString.cpp

```c++
#include "SString.h"

void strInit(SString &S)
{
	S.length=0;
}

void strAssign(SString &T,char *str)
{
	int i;
	for(i=1;str[i-1]!='\0';i++)
		T.ch[i]=str[i-1];
	T.length=i-1;
}

void strCopy(SString &T,SString S)
{
	for(int i=1;i<=S.length;i++)
		T.ch[i]=S.ch[i];
	T.length=S.length;
}

bool strEmpty(SString S)
{
	if(S.length==0)
		return true;
	else
		return false;
}

int strLength(SString S)
{
	return S.length;
}

void strPrint(SString S)
{
	for(int i=1;i<=S.length;i++)
		cout<<S.ch[i];
	cout<<endl;
}

void strClear(SString &S)
{
	S.length=0;
}

bool strSub(SString &Sub,SString &S,int pos,int len)
{
	if(pos+len-1>S.length)//子串范围越界
		return false;
	for(int i=pos;i<pos+len;i++)
		Sub.ch[i-pos+1]=S.ch[i];
	Sub.length=len;
	return true;
}

//S>T,return>0;S=T,return 0;S<T,return<0
int strCompare(SString S,SString T)
{
	for(int i=1;i<=S.length&&i<=T.length;i++)
		if(S.ch[i]!=T.ch[i])
			return S.ch[i]-T.ch[i];
	return S.length-T.length;
}

bool strConcat(SString &T,SString S1,SString S2)
{
	if(S1.length+S2.length>MAXLEN)
		return false;
	int i;
	for(i=1;i<=S1.length;i++)
		T.ch[i]=S1.ch[i];
	for(i=S1.length+1;i<=S1.length+S2.length+1;i++)
		T.ch[i]=S2.ch[i];
	T.length=S1.length+S2.length;
	return true;
}

int strIndex(SString S,SString T)
{
	int i=1,m=S.length,n=T.length;
	SString sub;
	while(i<=m-n+1)
	{
		strSub(sub,S,i,n);
		if(strCompare(sub,T)!=0)
			i++;
		else
			return i;
	}
	return 0;
}
```

## main.cpp

```c++
#include "SString.h"
 
int main()
{
	SString S,T;
	strInit(S);
	strInit(S);
	strAssign(S,"miabcmi");
	strAssign(T,"abc");
	strPrint(S);
	strPrint(T);
	cout<<"S-length:"<<strLength(S)<<endl;
	int index=strIndex(S,T);
	cout<<"the index of 'abc' in 'miabcmi':"<<index<<endl;
	return 0;
}
```

控制台结果:

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200603001858.png)

# 二、串的模式匹配

**串的模式匹配**:在主串中找到与**模式串(目标串,未必存在)**相同的**子串(真实存在)**,并返回其所在位置;否则返回0

## 1.朴素模式匹配算法

<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20200603003453585.png" alt="image-20200603003453585" style="zoom:80%;" />

**思路**:将主串中取出与模式串长度相同的子串,与模式串对比,只要子串有一个字符与模式串不同,就可以停止检查当前子串,从而继续检索下一个子串,直到匹配成功或遍历完成.

```c++
int index(SString S,SString T)
{
	int k=1;//记录主串当前检查的子串起始位置
	int i=k,j=1;
	while(i<=S.length&&j<=T.length)
	{
		if(S.ch[i]==T.ch[j])//继续比较后续字符
		{
			i++;
			j++;
		}
		else//检查下一个子串
		{
			k++;
			i=k;
			j=1;
		}
	}
	if(j>T.length)//找到
		return k;
	else
		return 0;
}
```

**时间复杂度分析**

若模式串长度为m,主串长度为n,n>>m,时间复杂度为**O(nm)**

|          | 最好情况             | 最差情况           | 平均情况 |
| -------- | -------------------- | ------------------ | -------- |
| 匹配成功 | O(m)                 | O(m*(n-m+1))≈O(nm) | O(n+m)   |
| 匹配失败 | O(n-m+1)=O(n-m)≈O(n) | O(m*(n-m+1))≈O(nm) | O(n+m)   |

## 2.朴素模式匹配算法优化——KMP算法

> 优化朴素模式匹配算法的主串的某些子串与模式串能部分匹配时,主串的扫描指针i经常回溯,导致时间开销增加的问题

**思路**:主串指针不回溯,**只有模式串指针回溯**.那回溯到哪里呢?

具体实现：https://zhuanlan.zhihu.com/p/75057892?utm_source=qq&utm_medium=social&utm_oi=639238434795950080

```c++

```

时间复杂度为**O(n+m)**