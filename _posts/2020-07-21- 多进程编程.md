---
layout:     post
title:      进程管理相关API
subtitle:   
date:       2020-07-21
author:     wukurua
header-img: img/os/post-bg-linux.png
catalog: true
tags:
    - linux
---

# 一、区别程序和进程

- 程序（program）：存放在磁盘文件中的可执行文件，是静态的（e.g. qq.exe）。
- 进程（process）：是正被执行的程序，要运行程序时，程序会被操作系统载入内存，是动态的，有生命周期的。进程是操作系统运行的最基本单元。

# 二、进程管理

那么操作系统如何管理进程呢？

- **识别进程**：每个进程都一定有一个唯一的数字标识符，称为进程ID（process ID），`PID`。
- **切换进程**：Linux系统是一个多进程（内核进程，用户进程）的系统，进程之间具有并行性、互不干扰的特点。 操作系统要切换进程时，需要保存进程相关的信息。Linux中进程包含**PCB**（进程控制块，process control block）、程序以及程序所操纵的数据结构集，可分为“代码段”、“数据段”和“堆栈段”。

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200721222215.png)

**进程状态：**

|     进程状态      |          宏定义           |
| :---------------: | :-----------------------: |
|     运行状态R     |       TASK_RUNNING        |
|  可中断睡眠状态S  |    TASK_INTERRUPTIBLE     |
| 不可中断睡眠状态D |   TASK_UNINTERRUPTIBLE    |
|     暂停状态T     | TASK_STOPPED或TASK_TRACED |
|     僵死状态Z     |        TASK_ZOMBIE        |
|     退出状态X     |         TASK_DEAD         |

**转换关系：**

# 三、进程管理相关API

## 1. fork

**官方文档：**

NAME
       **fork - create a child process**

SYNOPSIS

    #include <unistd.h>
    
    pid_t fork(void);

DESCRIPTION
       `fork()`  creates a new process by duplicating the calling process.  The new
       process is referred to as the <u>child</u> process.   The  calling  process  is
       referred to as the <u>parent</u> process.

​      The  child  process  and the parent process run in **separate** memory spaces.
​       At the time of `fork() `both memory spaces have the  same  content.   Memory
​       writes,  file  mappings (`mmap(2)`), and unmappings (`munmap(2)`) performed by
​       one of the processes do not affect the other.

RETURN VALUE
       On success, the `PID` of the child process is returned in the parent, and  0
       is  returned  in  the child.  On failure, -1 is returned in the parent, no
       child process is created, and errno is set appropriately.

**要点：**

- **一次调用，两次返回**：fork执行后会分别在父进程返回一个值，子进程返回一个值；其中，父进程的返回值>0,值为子进程的`pid`，子进程的返回值=0。通过fork的返回值可以区分父进程代码和子进程代码，一般来说子进程代码都写在`pid==0`的判断里,不会写在外面（子进程从生成它的fork之后开始执行，否则就会不断递归执行fork）。一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。

- **父子进程间不可以共享数据**：父子进程在不同的内存空间运行，fork相当于克隆了一个新的进程（fork之前对全局变量的修改,会影响fork之后的结果）

```c
#include <iostream>
#include <unistd.h>
using namespace std;

int number=10;

int main(int argc,char *argv[])
{
    pid_t pid;
    pid=fork();//create new process
    if(pid==0) //child process
    {
        //child process's code
        cout<<"child pid:"<<getpid()<<endl;
        for(int i=0;i<5;i++)
        {
            cout<<"child process run."<<endl;
            sleep(1);
            number++;
        }
        cout<<"number:"<<number<<endl;
        return 0;//finish child process
    }
    else if(pid>0)//father process
    {
        //father process's code
        cout<<"father pid:"<<getpid()<<endl;
        for(int i=0;i<2;i++)
        {
            cout<<"father process run."<<endl;
            sleep(2);
            number++;
        }
        cout<<"number:"<<number<<endl;
    }
    //execute this if not distinguish the return value of fork
    cout<<"Common exec:  pid:"<<getpid()<<endl;
    return 0;
}
```

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200721231029.png)

**僵尸进程**：子进程先于父进程结束，此时子进程的数据项是不会立刻释放的，虽然不再活跃了，可子进程还停留在系统里，因为它的退出码还需要保存起来以备父进程中后续的`wait`或`waitpid`调用使用。这时子进程是僵尸进程，占用的资源不会被操作系统回收，直到父进程结束为止。

例如：把上面的第28行代码`for(int i=0;i<2;i++)`改成`for(int i=0;i<50;i++)`,让父进程运行时间久一点以便我们观察僵尸进程。然后我们运行此段代码，等到子进程运行完出现，即出现number=15时，我们在终端执行`ps -au`命令查看当前运行的进程：

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200722001612.png)

图中红框的就是僵尸进程的相关信息，STAT为Z+。

**孤儿进程**：父进程先于子进程结束，子进程变成孤儿进程，父进程的pid会被系统回收变成1，而pid=1的进程是负责初始化的Init进程，这个时候子进程被Init进程所收养，Init进程是托管孤儿进程。

## 2. wait

**官方文档：**

NAME
       **wait, waitpid, waitid - wait for process to change state**

SYNOPSIS 

    #include <sys/types.h>
    #include <sys/wait.h>
    
    pid_t wait(int *status);
    pid_t waitpid(pid_t pid, int *status, int options);
DESCRIPTION
       All of these system calls are used to **wait for state changes in a child
       of  the  calling  process**, and **obtain information about the child whose
       state has changed**.  A state change is considered to be: 

​              1. the child  terminated; 

​              2. the child was stopped by a signal; 

​              3. or the child was resumed by a signal.  

​       In the case of a terminated child, performing a wait  allows
​       the  system  to  release  the resources associated with the child; **if a
​       wait is not performed, then the terminated child remains in a  "zombie"
​       state (see NOTES below).**

​       If  a  child has already changed state, then these calls return immedi‐
​       ately.  Otherwise, they block until either a child changes state  or  a
​       signal  handler interrupts the call (assuming that system calls are not
​       automatically restarted using the `SA_RESTART` flag of `sigaction(2)`).  In
​       the  remainder  of this page, a child whose state has changed and which
​       has not yet been waited upon by one of these  system  calls  is  termed
​       <u>waitable</u>.

要点：  

- 父进程必须等待子进程的结果,才能继续做

- `wait`,`waitpid`只能用于父进程,不能用于子进程

```c
#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
using namespace std;

int main(int argc,char *argv[])
{
    pid_t pid;
    pid=fork();
    int process_state=0;
    if(pid==0) //child process
    {
        //child process's code
        cout<<"child pid:"<<getpid()<<endl;
        for(int i=0;i<5;i++)
        {
            cout<<"child process run."<<endl;
            sleep(1);
        }
        return 233;//now return 233
    }
    else if(pid>0)//father process
    {
        sleep(1);//prevent child process from being too late to start execution
        pid=wait(&process_state);
        if(WIFEXITED(process_state))//complete normally
        {
            cout<<"child exec code:"<<WEXITSTATUS(process_state)<<endl;
        }
        cout<<"father pid:"<<getpid()<<endl;
        cout<<"wait child pid:"<<pid<<endl;
        for(int i=0;i<3;i++)
        {
            cout<<"child process run."<<endl;
            sleep(2);
        }
    }
    //execute this if not distinguish the return value of fork
    cout<<"Common exec:  pid:"<<getpid()<<endl;
    return 0;
}

```



![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200721211002.png)

使用`waitpid`等待指定pid的进程的状态改变再执行父进程：

```c
#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
using namespace std;

int main(int argc,char *argv[])
{
    pid_t pid;
    pid=fork();
    int process_state=0;
    if(pid==0)//child process
    {
        cout<<"child pid:"<<getpid()<<endl;
        for(int i=0;i<5;i++)
        {
            cout<<"child process run."<<endl;
            sleep(1);
        }
        return 233;
    }
    else if(pid>0)//father process
    {
        pid=fork();
        if(pid==0)//child process
        {
            cout<<"child2 pid:"<<getpid()<<endl;
            for(int i=0;i<5;i++)
            {
                cout<<"child2 process run."<<endl;
                sleep(1);
            }
            return 77;
        }
        pid=waitpid(pid,&process_state,0);

        if(WIFEXITED(process_state))//complete normally
        {
            cout<<"child exec code:"<<WEXITSTATUS(process_state)<<endl;
        }
        cout<<"father pid:"<<getpid()<<endl;
        cout<<"wait child pid:"<<pid<<endl;
        for(int i=0;i<3;i++)
        {
            cout<<"child process run."<<endl;
            sleep(2);
        }
    }
    //execute this if not distinguish the return value of fork
    cout<<"Common exec:  pid:"<<getpid()<<endl;
    return 0;
}
```

