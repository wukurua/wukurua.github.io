---
layout:     post
title:      守护进程
subtitle:   
date:       2020-07-23
author:     wukurua
header-img: img/linux/post-bg-linux.png
catalog: true
tags:
    - linux
---

# 一、创建守护进程

子进程不想被替创建守护进程

操作系统的后台有很多进程在后台默默运行

windows叫服务，linux叫守护进程

<img src="https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200723200752.png" style="zoom: 50%;" />

守护进程，由终端启动,启动后就脱离终端,在linux后台运行

进程组,会话,终端

进程组:每个进程创建的时候都会产生一个进程组,进程组中可以包含一个或多个进程,进程组中有一个进程组长,组长的`PID`就是进程组的id,`PGID`

程序通过终端启动，调用fork产生子进程，构成进程组，多个进程组构成一个会话。

通过一个会话可以创建一个终端,每一个创建会话的终端叫SID,会话id

一个会话对应一个终端,会话可以创建终端

```c
#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>
using namespace std;

int main(int argc,char *argv[])
{
    pid_t pid;
    pid=fork();
    if(pid==0)
    {
        cout<<"child pid:"<<getpid()<<endl;
        cout<<"child pgid:"<<getpgid(getpid())<<endl;
        return 0;
    }
    else if(pid>0)
    {
        cout<<"father id:"<<getpid()<<endl;
        cout<<"father pgid:"<<getpgid(getpid())<<endl;
    }
    return 0;
}
```

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200723204440.png)

编写守护程序,在后台运行程序:

1. 这个进程必须脱离当前终端,即必须自己创建会话,可以使用`setsid`函数来创建一个会话
2. 但此函数的使用前提是调用函数的进程不能是进程组组长,即只有子进程才能成功调用`setsid`函数，所以要先`fork`出一个子进程。

创建完一个新的会话后,它有可能创建一个终端.要想创建一个终端必须是进程组组长,所以这时我们还要再创建子进程,因为它没有权利创建一个新终端

终端能接受用户输入字符和显示结果

return调用的时候在main函数就是整个进程结束

exit是进程结束的函数,不管是否在main函数

```c
#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>
using namespace std;

int main(int argc,char *argv[])
{
    pid_t pid;
    pid=fork();
    if(pid==0)
    {
        setsid();
        pid=fork();
        if(pid==0)
        {
            while(1)
            {
                sleep(1);
            }
        }
        return 0;
    }
    return 0;
}

```



![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200723211639.png)



```c
void creatSession()
{
    pid_t pid;
    pid=fork();
    if(pid==0)
    {
        setsid();
        pid=fork();
        if(pid==0)
        {

        }
        else if(pid>0)
        {
            exit(0);
        }
    }
    else if(pid>0)
    {
        exit(0);
    }
}
```

一般地,守护进程,创建会话后是脱离终端的程序,那么默认情况下linux下面的0,1,2文件描述符都要关掉

0:标准输入(键盘)

1:标准输出(显示器)

2:错误输出

`close()`

守护进程的默认目录本来是自己的可执行程序目录,`chdir`进行切换,到一个公用的目录


