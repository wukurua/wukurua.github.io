---
layout:     post
title:      手撕数据结构——二叉树
subtitle:   二叉树,二叉线索树,树,森林
date:       2020-08-07
author:     wukurua
header-img: img/DS/post-bg-ds.png
catalog: true
tags:
    - Data Structure
---

# 一、二叉树的基本操作

## BitTree.h

```c++
#ifndef BITREE_H
#define BITREE_H
#include <iostream>
#include <queue>
#include <stack>
using namespace std;

typedef struct BiTNode
{
	char data;
	struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

BiTree bitreeCreate();
void preOrderRec(BiTree &T);//递归先序遍历
void inOrderRec(BiTree &T);//递归中序遍历
void postOrderRec(BiTree &T);//递归后序遍历
void preOrderNonRec(BiTree &T);//非递归先序遍历
void inOrderNonRec(BiTree &T);//非递归中序遍历
void postOrderNonRec(BiTree &T);//非递归后序遍历
void levelOrder(BiTree &T);//层次遍历
int depth(BiTree &T);//求深度
#endif
```

## BitTree.cpp

```c++
#include "BiTree.h"

BiTree bitreeCreate()
{
	BiTree T;
	char ch;
	scanf("%c", &ch);
    if(ch!='#')
    {
		T=(BiTree)malloc(sizeof(BiTNode));
        T->data=ch;
        T->lchild=bitreeCreate();
        T->rchild=bitreeCreate();
    }
	else	
	{
		T=NULL;
	}
	return T;
}

//递归先序遍历
void preOrderRec(BiTree &T)
{
	if(T!=NULL)
	{
		cout<<T->data;
		preOrderRec(T->lchild);
		preOrderRec(T->rchild);
	}
}

//递归中序遍历
void inOrderRec(BiTree &T)
{
	if(T!=NULL)
	{
		inOrderRec(T->lchild);
		cout<<T->data;
		inOrderRec(T->rchild);
	}
}

//递归后序遍历
void postOrderRec(BiTree &T)
{
	if(T!=NULL)
	{
		postOrderRec(T->lchild);
		postOrderRec(T->rchild);
		cout<<T->data;
	}
}

//非递归先序遍历
void preOrderNonRec(BiTree &T)
{
	stack<BiTree> S;//辅助栈
	BiTree p=T;
	while(p||!S.empty())
	{
		if(p)//一路向左
		{
			cout<<p->data;
			S.push(p);
			p=p->lchild;
		}
		else 
		{	
			p=S.top();
			S.pop();
			p=p->rchild;
		}
	}
}

//非递归中序遍历
void inOrderNonRec(BiTree &T)
{
	stack<BiTree> S;//辅助栈
	BiTree p=T;
	while(p||!S.empty())
	{
		if(p)//一路向左
		{
			S.push(p);
			p=p->lchild;//左孩子不空就一直向左走
		}
		else 
		{	
			p=S.top();
			cout<<p->data;
			S.pop();
			p=p->rchild;
		}
	}
}

//非递归后序遍历
void postOrderNonRec(BiTree &T)
{
	stack<BiTree> S;//辅助栈
	BiTree p=T;
	BiTree r=NULL;//辅助指针保存上次访问的节点是位于左子树还是右子树,
	while(p||!S.empty())
	{
		if(p)//一路向左
		{
			S.push(p);
			p=p->lchild;
		}
		else 
		{	
			p=S.top();
			if(p->rchild&&p->rchild!=r)//若右子树存在,且未被访问过
			{
				p=p->rchild;//转向右
				S.push(p);
				p=p->lchild;//再走到最左
			}
			else//否则就弹出结点并访问
			{
				cout<<p->data;
				S.pop();
				r=p;//记录上次访问的节点
				p=NULL;//出栈访问完一个结点相当于遍历完以该结点为根的子树,需重置p为NULL!
			}
		}
	}
}

//层次遍历
void levelOrder(BiTree &T)
{
	queue<BiTree> Q;//辅助队列
	Q.push(T);
	while(!Q.empty())
	{
		BiTree node=Q.front();
		cout<<node->data;
		Q.pop();
		if(node->lchild!=NULL)
			Q.push(node->lchild);
		if(node->rchild!=NULL)
			Q.push(node->rchild);
	}
}

int depth(BiTree &T)
{
	if(T==NULL)
		return 0;
	else
	{
		int l=depth(T->lchild);
		int r=depth(T->rchild);
		return l>r?l+1:r+1;
	}
}
```



![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200807005736.png)

# 二、线索二叉树

## ThreadTree.h

```c++
#ifndef THREADTREE_H
#define THREADTREE_H
#include <iostream>
#include <queue>
#include <stack>
using namespace std;

typedef struct ThreadNode
{
	char data;
	struct ThreadNode *lchild,*rchild;
	int ltag,rtag;//左右线索标志
	//tag=0表示指针指向孩子,tag=1表示指针是线索
}ThreadNode,*ThreadTree;

ThreadTree bitreeCreate();
/*线索化*/
void dealNode(ThreadTree &p,ThreadTree &pre);//处理结点的线索化
void PreThread(ThreadTree &p,ThreadTree &pre);//递归的先序线索化
void InThread(ThreadTree &p,ThreadTree &pre);//递归的中序线索化
void PostThread(ThreadTree &p,ThreadTree &pre);//递归的后序线索化
void createPreThread(ThreadTree &T);//创建先序线索二叉树
void createInThread(ThreadTree &T);//创建中序线索二叉树
void createPostThread(ThreadTree &T);//创建后序线索二叉树

/*中序遍历*/
ThreadNode *FirstNode(ThreadNode *p);//找到以p为根的子树中,第一个被中序遍历的结点
ThreadNode *LastNode(ThreadNode *p);//找到以p为根的子树中,最后一个被中序遍历的结点
ThreadNode *NextNodeInOrder(ThreadNode *p);//在中序线索二叉树中找到结点p的后续结点
ThreadNode *PreNodeInOrder(ThreadNode *p);//在中序线索二叉树中找到结点p的前驱结点
void InOrder(ThreadNode *T);//利用线索实现的非递归中序遍历
void RevInOrder(ThreadNode *T);//利用线索实现的非递归中序逆向遍历

/*先序遍历*/
ThreadNode *NextNodePreOrder(ThreadNode *p);//在先序线索二叉树中找到结点p的后续结点
//在先序线索二叉树中找到结点p的前驱结点,需要改用三叉链表以找到父结点
void PreOrder(ThreadNode *T);//利用线索实现的非递归先序遍历

/*后序遍历*/
ThreadNode *NextNodePostOrder(ThreadNode *p);//在后序线索二叉树中找到结点p的前驱结点
//在后序线索二叉树中找到结点p的后续结点,需要改用三叉链表以找到父结点
void RevPostOrder(ThreadNode *T);//利用线索实现的非递归后序逆序遍历
#endif
```

## ThreadTree.cpp

```c++
#include "ThreadTree.h"

ThreadTree bitreeCreate()
{
	ThreadTree T;
	char ch;
	scanf("%c", &ch);
    if(ch!='#')
    {
		T=(ThreadTree)malloc(sizeof(ThreadNode));
        T->data=ch;
        T->lchild=bitreeCreate();
        T->rchild=bitreeCreate();
		T->ltag=0;
		T->rtag=0;
    }
	else	
	{
		T=NULL;
	}
	return T;
}

void dealNode(ThreadTree &p,ThreadTree &pre)
{
	if(p->lchild==NULL)
	{
		p->lchild=pre;
		p->ltag=1;
	}
	if(pre!=NULL&&pre->rchild==NULL)
	{
		pre->rchild=p;
		pre->rtag=1;
	}
	pre=p;
}

void PreThread(ThreadTree &p,ThreadTree &pre)
{
	if(p!=NULL)
	{
		dealNode(p,pre);
		//因为pre->rchild=p,可能会导致在pre,p两个结点间反复转圈
		if(p->ltag==0)
			PreThread(p->lchild,pre);
		PreThread(p->rchild,pre);
	}
}

void InThread(ThreadTree &p,ThreadTree &pre)
{
	if(p!=NULL)
	{
		InThread(p->lchild,pre);
		dealNode(p,pre);
		InThread(p->rchild,pre);
	}
}

void PostThread(ThreadTree &p,ThreadTree &pre)
{
	if(p!=NULL)
	{
		PostThread(p->lchild,pre);
		PostThread(p->rchild,pre);
		dealNode(p,pre);
	}
}

void createPreThread(ThreadTree &T)
{
	ThreadNode *pre=NULL;
	if(T!=NULL)
	{
		PreThread(T,pre);
		if(pre->rchild==NULL)
			pre->rtag=1;
	}
}

void createInThread(ThreadTree &T)
{
	ThreadNode *pre=NULL;
	if(T!=NULL)
	{
		InThread(T,pre);
		if(pre->rchild==NULL)
			pre->rtag=1;
	}
}

void createPostThread(ThreadTree &T)
{
	ThreadNode *pre=NULL;
	if(T!=NULL)
	{
		PostThread(T,pre);
		if(pre->rchild==NULL)
			pre->rtag=1;
	}
}

/*中序*/
ThreadNode *FirstNode(ThreadNode *p)
{
	//循环找到最左下结点	
	while(p->ltag==0)
		p=p->lchild;
	return p;
}

ThreadNode *LastNode(ThreadNode *p)
{
	//循环找到最右下结点	
	while(p->rtag==0)
		p=p->rchild;
	return p;
}

ThreadNode *NextNodeInOrder(ThreadNode *p)
{
	if(p->rtag==0)//有右孩子
		return FirstNode(p->rchild);
	else//右指针已经被线索化
		return p->rchild;
}

ThreadNode *PreNodeInOrder(ThreadNode *p)
{
	if(p->ltag==0)//有左孩子
		return LastNode(p->lchild);
	else//左指针已经被线索化
		return p->lchild;
}

//空间复杂度O(1);
void InOrder(ThreadNode *T)
{
	for(ThreadNode *p=FirstNode(T);p!=NULL;p=NextNodeInOrder(p))
		cout<<p->data;
}

void RevInOrder(ThreadNode *T)
{
	for(ThreadNode *p=LastNode(T);p!=NULL;p=PreNodeInOrder(p))
		cout<<p->data;
}

/*先序*/
ThreadNode *NextNodePreOrder(ThreadNode *p)
{
	if(p->rtag==0)//有右孩子
	{
		if(p->ltag==0)//若p有左孩子,则先序后继为左孩子
			return p->lchild;
		else//若p没有左孩子,则先序后继为右孩子
			return p->rchild;
	}	
	else//右指针已经被线索化
		return p->rchild;
}

void PreOrder(ThreadNode *T)
{
	for(ThreadNode *p=T;p!=NULL;p=NextNodePreOrder(p))
		cout<<p->data;
}


/*后序*/
ThreadNode *NextNodePostOrder(ThreadNode *p)
{
	if(p->ltag==0)//有左孩子
	{
		if(p->ltag==0)//若p有右孩子,则后序前驱为右孩子
			return p->rchild;
		else//若p没有右孩子,则后序前驱为左孩子
			return p->lchild;
	}	
	else//左指针已经被线索化
		return p->lchild;
}

void RevPostOrder(ThreadNode *T)
{
	for(ThreadNode *p=T;p!=NULL;p=NextNodePostOrder(p))
		cout<<p->data;
}
```

## 总结

|        | 中序线索二叉树 | 先序线索二叉树 | 后序线索二叉树 |
| :----: | :------------: | :------------: | :------------: |
| 找前驱 |       ✅        |       ❌        |       ✅        |
| 找后继 |       ✅        |       ✅        |       ❌        |

除非用：

- **三叉链表**
- 从**根开始遍历寻找**

# 三、树的三种表示方法

## 1.双亲表示法(顺序存储)

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200810150817.png)

找父节点方便，找孩子不方便。

```c++
#define MAX_TREE_SIZE 100
typedef struct
{
	char data;
	int parent;//双亲位置域
}PTNode;

typedef struct
{
	PTNode nodes[MAX_TREE_SIZE];//双亲表示
	int n;//结点数
}PTree;
```

## 2.孩子表示法(顺序+链式存储)

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200810150754.png)

找孩子方便，找父节点不方便。

```c++
#define MAX_TREE_SIZE 100

typedef struct
{
	int child;//孩子结点在数组中的位置
	struct CTNode *next ;//下一个孩子
}CTNode;

typedef struct
{
	char data;
	struct CTNode *firstChild;//第一个孩子
}CTBox;

typedef struct
{
	CTBox nodes[MAX_TREE_SIZE];
	int n,r;//结点数,根的位置
}CTree;
```

## 3.孩子兄弟表示法(链式存储)

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200810151221.png)

用二叉链表存储树——**左孩子右兄弟**

```c++
typedef CSNode
{
	char data;
	struct CSNode *firstChild,*nextsibling;//第一个孩子,右兄弟指针(二叉链表)
}CSNode,*CSTree;
```

## 4.森林与二叉树的转换

用二叉链表存储森林——**左孩子右兄弟**

![](https://cdn.jsdelivr.net/gh/wukurua/cloudimg@master/img/20200810153453.png)

**森林中各个树的根节点之间视为兄弟关系**

## 5.树、森林的遍历

- 树没有“中”这个概念,没有树的中根遍历这种东西

- 森林的中序遍历本应该是后序遍历，之所以这样命名为森林的中序遍历，是因为这种遍历等同于将森林转换为二叉树之后，对二叉树的中序遍历。

|           树           |      森林      |  二叉树  |
| :--------------------: | :------------: | :------: |
| 先根遍历(深度优先遍历) |    先序遍历    | 先序序列 |
|        后根遍历        | 中序(后序)遍历 | 中序序列 |
| 层次遍历(广度优先遍历) |                |          |

