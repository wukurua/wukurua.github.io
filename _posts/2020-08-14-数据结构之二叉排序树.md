---
layout:     post
title:      手撕数据结构——二叉排序树
subtitle:   
date:       2020-08-14
author:     wukurua
header-img: img/DS/post-bg-ds.png
catalog: true
tags:
    - Data Structure
---



## BSTree.h

```c++
#ifndef BITREE_H
#define BITREE_H
#include <iostream>
#include <queue>
#include <stack>
using namespace std;

typedef struct BSTNode
{
	int key;
	struct BSTNode *lchild,*rchild;
}BSTNode,*BSTree;

/*建立*/
void BST_create(BSTree &T,int str[],int n);

/*查找*/
BSTNode *BST_search_non_rec(BSTree T,int key);//非递归实现
BSTNode *BST_search_rec(BSTree T,int key);//递归实现

/*插入*/
int BST_insert_non_rec(BSTree &T,int key);//非递归实现
int BST_insert_rec(BSTree &T,int key);//递归实现

/*删除*/
int BST_insert_del(BSTree &T,int key);

/*遍历*/
void inOrderRec(BSTree T);

#endif
```

## BSTree.cpp

```c++
#include "BiTree.h"

void BST_create(BSTree &T,int str[],int n)
{
	T=NULL;
	for(int i=0;i<n;i++)
	{
		BST_insert_rec(T,str[i]);
	}
}

//空间复杂度O(1)
BSTNode *BST_search_non_rec(BSTree T,int key)
{
	while(T!=NULL&&key!=T->key)//树空或等于根结点值,则结束循环
	{
		if(key<T->key)
			T=T->lchild;
		else
			T=T->rchild;
	}
	return T;
}

//空间复杂度O(h)
BSTNode *BST_search_rec(BSTree T,int key)
{
	if(T==NULL)
		return NULL;
	if(key==T->key)
		return T;
	else if(key<T->key)
		return BST_search_rec(T->lchild,key);
	else if(key>T->key)  
		return BST_search_rec(T->rchild,key);
}

//空间复杂度O(1)
int BST_insert_non_rec(BSTree &T,int key)
{
	BSTNode *p=T;
	while(p!=NULL)
	{
		if(key==p->key)
			return 0;
		else if(key<p->key)
			p=p->lchild;
		else if(key>p->key)
			p=p->rchild;
	}
	if(p==NULL)
	{
		BSTNode *node=(BSTree)malloc(sizeof(BSTNode));
		node->key=key;
		node->lchild=node->rchild=NULL;
		p=node;
	}
	return 1;
}

//空间复杂度O(h)
int BST_insert_rec(BSTree &T,int key)
{
	if(T==NULL)
	{
		T=(BSTree)malloc(sizeof(BSTNode));
		T->key=key;
		T->lchild=T->rchild=NULL;
		return 1;
	}
	else if(key==T->key)
		return 0;
	else if(key<T->key)
		return BST_insert_rec(T->lchild,key);
	else
		return BST_insert_rec(T->rchild,key);

}

int BST_insert_del(BSTree &T,int key);
{
	//等待填坑
}

void inOrderRec(BSTree T)
{
	if(T!=NULL)
	{
		inOrderRec(T->lchild);
		cout<<T->key<<" ";
		inOrderRec(T->rchild);
	}
}
```


